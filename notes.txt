26/9/18
    main electron window set up
    apparently it won't initialise if electron is attempting to be initialised in another file
    (it needs to be initiated within the js file you ran the electron command with)

9/10/18
    apparently in the render process, you need remote.require("./yourlocalmodule") for it to work
    (that's if you use <script src=""></script> instead of <script>window.onload = () => {require("./thing");}</script>)
    
14/11/18
    Current gameplan:
    The server object will always persist as long as the program's running
    But when the player starts a new game/hosts, then the server will .listen()
    And the clientside will have the socket.io client library to use io.connect
    
21/11/18
    FYI, IPC will not transfer functions, as it's JSON'ised
    So remote.getGlobal must be used for the server

4/12/18
    You can send functions in socket.emit()!

13/12/18
    Working on loading/instantiating world data

14/1/19
    Work on listing available worlds in start-config.html/js and start implementing transferring
    the proper world data from the main thread to the client thread
    Refactored the require's in erver.js

16/1/19
    It's a pain in the ass for the server to try and get what the current world name is,
    The server object now contains the Game object (similar to the old mapocalypse one)

29/1/19
    Available locally saved worlds are properly listed in start-configure's load section
    Need to work on saving newly created worlds (as they're the host)

6/2/2019
    Worlds now save properly and show up on the start-config load list
    Also, some sanitisation on world creation inputs
    Also, localisation has been imported from the old mapocalypse, hopefully i can integrate most of the old
    code back into this project, but new this locale needs to be extended for the other menus

25/2/2019
    Start-config's Load section can initiate the world and delete worlds too
    You can now connect! (Try getting your local ipv4 address, open multiple instances and get one to connect to the other).
    Also, refactored gameLoadInfo a bit so now it's not a separate useless class.js, but rather a helper function.
    Players.json has been added to keep track on the current/past players that have locally "logged in" to keep track of player entities/their states.

27/2/2019
    Google maps api must be loaded >before< the webpage fully loads, or else you can't reference google objects in your code.
    Made progress, a map now loads (GameMap), but you can't dynamically change the key within the game-client page.
    (my school google account's google maps api key doesn't work because it's a newer account
    which requires billing info to work) So I'm just using my old personal mapocalypse api key

28/2/2019
    functions in server and gameclient to more easily transmit/send data

4/3/2019
    Enabled experimental web features in browserwindow creation... for blurred divs lol
    a lotta CSS
    On connection, client will send player info to server, and the server will update this.players
    and broadcast the new player's existance to the others
    Also on disconnect, remember to remove them.
    For some reason, GameClient can't call its own prototype functions in the constructor... it works in server()...

6/3/2019
    Updated helpers.getActivePlayerInfo() so that it reads from RAM from the main process
    as opposed to reading it from file which could cause clashes
    so in essence, player.json's "active" key is completely pointless now, 
    but I'll sort it out next time
    Just committing this so i can pull it from my other PC 
    the joining process works! sending playerPackets to and fro' (playerPacket is just a single-key object
    with the key being the socket.id, and the value being playerInfo)
